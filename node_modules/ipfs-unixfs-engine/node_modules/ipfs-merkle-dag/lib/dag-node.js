'use strict';

var util = require('./util');
var protobuf = require('protocol-buffers');
var stable = require('stable');
var bs58 = require('bs58');

var schema = 'message PBLink {optional bytes Hash = 1; optional string Name = 2;optional uint64 Tsize = 3;} message PBNode {repeated PBLink Links = 2; optional bytes Data = 1;}';

var mdagpb = protobuf(schema);

exports = module.exports = {
  DAGLink: DAGLink,
  DAGNode: DAGNode
};

function DAGNode(data, links) {
  var _this = this;

  var cached;
  var encoded;

  this.data = data;
  this.links = links || [];

  function linkSort(a, b) {
    return new Buffer(a.name, 'ascii').compare(new Buffer(b.name, 'ascii'));
  }

  // copy - returns a clone of the DAGNode
  this.copy = function () {
    var clone = new DAGNode();
    if (_this.data && _this.data.length > 0) {
      var buf = new Buffer(_this.data.length);
      _this.data.copy(buf);
      clone.data = buf;
    }

    if (_this.links.length > 0) {
      clone.links = links.slice();
    }

    return clone;
  };

  // addNodeLink - adds a DAGLink to this node that points to node by a name
  this.addNodeLink = function (name, node) {
    if (typeof name !== 'string') {
      return;
    }
    var link = _this.makeLink(node);

    link.name = name;
    _this.addRawLink(link);
  };

  // addRawLink adds a Link to this node from a DAGLink
  this.addRawLink = function (link) {
    encoded = null;
    _this.links.push(new DAGLink(link.name, link.size, link.hash));
    stable.inplace(_this.links, linkSort);
  };

  // UpdateNodeLink return a copy of the node with the link name set to point to
  // that. If a link of the same name existed, it is replaced.
  // TODO this would make more sense as an utility
  this.updateNodeLink = function (name, node) {
    var newnode = _this.copy();
    newnode.removeNodeLink(name);
    newnode.addNodeLink(name, node);
    return newnode;
  };

  // removeNodeLink removes a Link from this node based on name
  this.removeNodeLink = function (name) {
    encoded = null; // uncache
    _this.links = _this.links.filter(function (link) {
      if (link.name === name) {
        return false;
      } else {
        return true;
      }
    });
  };
  // removeNodeLink removes a Link from this node based on a multihash
  this.removeNodeLinkByHash = function (multihash) {
    encoded = null; // uncache
    _this.links = _this.links.filter(function (link) {
      if (link.hash.equals(multihash)) {
        return false;
      } else {
        return true;
      }
    });
  };

  // removeNodeLink removes a Link from this node based on name
  this.removeNodeLink = function (name) {
    encoded = null; // uncache
    _this.links = _this.links.filter(function (link) {
      if (link.name === name) {
        return false;
      } else {
        return true;
      }
    });
  };

  // makeLink returns a DAGLink node from a DAGNode
  // TODO: this would make more sense as an utility
  this.makeLink = function (node) {
    var size = node.size();
    var mh = node.multihash();
    return new DAGLink(null, size, mh);
  };

  // multihash - returns the multihash value of this DAGNode
  this.multihash = function () {
    _this.encoded();
    return cached;
  };

  // Size returns the total size of the data addressed by node,
  // including the total sizes of references.
  this.size = function () {
    var buf = _this.encoded();
    if (!buf) {
      return 0;
    }
    var size = buf.length;
    for (var i = 0; i < _this.links.length; i++) {
      size += _this.links[i].size;
    }
    return size;
  };

  // Encoded returns the encoded raw data version of a Node instance.
  // It may use a cached encoded version, unless the force flag is given.
  this.encoded = function (force) {
    if (force || !encoded) {
      encoded = _this.marshal();

      if (encoded) {
        cached = util.hash(encoded);
      }
    }
    return encoded;
  };

  // marshal - encodes the DAGNode into a probuf
  this.marshal = function () {
    var pbn = toProtoBuf(_this);
    var data = mdagpb.PBNode.encode(pbn);
    return data;
  };

  // unMarshal - decodes a protobuf into a DAGNode
  // TODO: this would make more sense as an utility
  this.unMarshal = function (data) {
    var pbn = mdagpb.PBNode.decode(data);
    this.links = [];
    for (var i = 0; i < pbn.Links.length; i++) {
      var link = pbn.Links[i];
      var lnk = new DAGLink(link.Name, link.Tsize, link.Hash);
      this.links.push(lnk);
    }
    stable.inplace(this.links, linkSort);
    this.data = pbn.Data || new Buffer(0);
    return this;
  };

  // Helper method to get a protobuf object equivalent
  function toProtoBuf(node) {
    var pbn = {};

    if (node.data && node.data.length > 0) {
      pbn.Data = node.data;
    } else {
      pbn.Data = null; // new Buffer(0)
    }

    if (node.links.length > 0) {
      pbn.Links = [];

      for (var i = 0; i < node.links.length; i++) {
        var link = node.links[i];
        pbn.Links.push({
          Hash: link.hash,
          Name: link.name,
          Tsize: link.size
        });
      }
    } else {
      pbn.Links = null;
    }

    return pbn;
  }

  this.toJSON = function () {
    return {
      Data: _this.data,
      Links: _this.links.map(function (l) {
        return l.toJSON();
      }),
      Hash: bs58.encode(_this.multihash()).toString(),
      Size: _this.size()
    };
  };
}

// Link represents an IPFS Merkle DAG Link between Nodes.
function DAGLink(name, size, hash) {
  var _this2 = this;

  this.name = name;
  this.size = size;
  this.hash = hash;

  this.toJSON = function () {
    return {
      Name: _this2.name,
      Size: _this2.size,
      Hash: bs58.encode(_this2.hash).toString()
    };
  };
}